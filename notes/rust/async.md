# 异步编程

要支持异步编程最好先支持coroutine(协程)，而协程实现可以分为有栈(比较耗内存)和无栈(状态机)两种

Rust选择了性能更好的状态机协程实现(具体对比看刀哥Rust笔记有介绍)

无栈协程的经典应用是——Generator(生成器)，例如Python的yield

## 生成器模拟Future

相比迭代器，生成器是一种延迟计算或惰性计算

不过生成器也类似迭代器，也适用于序列化几千万条MySQL记录去处理或迭代一个很大的排列组合，每次只在内存中存一条，避免了内存中放不下的问题

如果将生成器返回Yielded看做Pending，Complete表示Ready，不断轮询生成器，则可以得到类似Future的效果

但是生成器能力较弱，只能在调用者和自身间转移CPU使用权，不能实现Future套娃使用

在Future的线程池消息轮询队列中，如果发现当前任务是Pending状态，则重新将该任务发送到Channel中等待下一次轮询

## 为了异步编程特意引入的Pin


